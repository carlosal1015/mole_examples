<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of addBC2D</title>
  <meta name="keywords" content="addBC2D">
  <meta name="description" content="This function assumes that the unknown u, which represents the discrete">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="index.html">matlab</a> &gt; addBC2D.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src/matlab&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>addBC2D
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This function assumes that the unknown u, which represents the discrete</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [A, b] = addBC2D(A, b, k, m, dx, n, dy, dc, nc, v) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> This function assumes that the unknown u, which represents the discrete
 solution the continuous second-order 2D PDE operator 
                                   L U = f, 
 with continuous boundary condition 
                              a0 U + b0 dU/dn = g,
 are given at the 2D cell centers and boundary face centers. Furthermore,
 all discrete calculations are performed at the 2D cell centers and boundary 
 face centers.

 The function receives as input quantities associated to the discrete
 analog of the continuous problem given by the squared linear system 
                                 A u = b 
 where A is the discrete analog of L and b is the discrete analog of g,
 both constructed by the user without boundary conditions.
 The function output is the modified square linear system 
                                 A u = b
 where both A and b include boundary condition information.

 The boundary condition is always one of the following forms:

 For Dirichlet set: a0 not equal zero and b0 = 0.
 For Neumann set  : a0 = 0 and b0 not equal zero.
 For Robin set    : both a0 and b0 not equal zero.
 For Periodic set : both a0 = 0 and b0 = 0.

 For periodic bc, it is assumed that not only u but also du/dn are the same 
 in both extremes of the domain since a second-order PDE is assumed.

 Periodic boundary conditions can be applied along some axes and
 non-periodic to some others.
 
 For consistence with the way boundary operators are calculated to avoid 
 overwriting of the values v, the left and right boundary conditions are
 assumed to be column vectors of (m+2)*n components, and the bottom and 
 top faces are assumed to be vectors of (m+2)*(n+2) components. 

 The order of these components is as follows:
 For left and right edges, the ordering is the one given by columns vectors
 where x increases. For bottom and top faces, the ordering is the one given 
 by columns vectors where y increases.

 The code assumes the following assertions:
 assert(k &gt;= 2, 'k &gt;= 2');
 assert(mod(k, 2) == 0, 'k % 2 = 0');
 assert(m &gt;= 2*k+1, ['m &gt;= ' num2str(2*k+1) ' for k = ' num2str(k)]);

 Parameters:
 output
         A : Linear operator with boundary conditions added
         b : Right hand side with boundary conditions added

 input
         A : Linear operator without boundary conditions added
         b : Right hand side without boundary conditions added
         k : Order of accuracy
         m : Number of horizontal cells
        dx : Step size horizontal cells
         n : Number of vertical cells
        dy : Step size of vertical cells
        dc : a0 (4x1 vector for left, right, bottom, top boundaries, resp.)
        nc : b0 (4x1 vector for left, right, bottom, top boundaries, resp.)
         v : g (4x1 vector of arrays for left, right, bottom, top boundaries, resp.)
 ----------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-3.0-or-later
 Â© 2008-2024 San Diego State University Research Foundation (SDSURF).
 See LICENSE file or https://www.gnu.org/licenses/gpl-3.0.html for details.
 ----------------------------------------------------------------------------
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="addBC2Dlhs.html" class="code" title="function [Abcl,Abcr,Abcb,Abct] = addBC2Dlhs(k, m, dx, n, dy, dc, nc)">addBC2Dlhs</a>	This functions uses geometry and boundary type conditions to create</li>
<li><a href="addBC2Drhs.html" class="code" title="function b = addBC2Drhs(b, dc, nc, v, rl, rr, rb, rt)">addBC2Drhs</a>	function b = addBC2Drhs(b, m, n, dc, nc, v, vec)</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [A, b] = addBC2D(A, b, k, m, dx, n, dy, dc, nc, v)</a>
0002 <span class="comment">% This function assumes that the unknown u, which represents the discrete</span>
0003 <span class="comment">% solution the continuous second-order 2D PDE operator</span>
0004 <span class="comment">%                                   L U = f,</span>
0005 <span class="comment">% with continuous boundary condition</span>
0006 <span class="comment">%                              a0 U + b0 dU/dn = g,</span>
0007 <span class="comment">% are given at the 2D cell centers and boundary face centers. Furthermore,</span>
0008 <span class="comment">% all discrete calculations are performed at the 2D cell centers and boundary</span>
0009 <span class="comment">% face centers.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% The function receives as input quantities associated to the discrete</span>
0012 <span class="comment">% analog of the continuous problem given by the squared linear system</span>
0013 <span class="comment">%                                 A u = b</span>
0014 <span class="comment">% where A is the discrete analog of L and b is the discrete analog of g,</span>
0015 <span class="comment">% both constructed by the user without boundary conditions.</span>
0016 <span class="comment">% The function output is the modified square linear system</span>
0017 <span class="comment">%                                 A u = b</span>
0018 <span class="comment">% where both A and b include boundary condition information.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% The boundary condition is always one of the following forms:</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% For Dirichlet set: a0 not equal zero and b0 = 0.</span>
0023 <span class="comment">% For Neumann set  : a0 = 0 and b0 not equal zero.</span>
0024 <span class="comment">% For Robin set    : both a0 and b0 not equal zero.</span>
0025 <span class="comment">% For Periodic set : both a0 = 0 and b0 = 0.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% For periodic bc, it is assumed that not only u but also du/dn are the same</span>
0028 <span class="comment">% in both extremes of the domain since a second-order PDE is assumed.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Periodic boundary conditions can be applied along some axes and</span>
0031 <span class="comment">% non-periodic to some others.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% For consistence with the way boundary operators are calculated to avoid</span>
0034 <span class="comment">% overwriting of the values v, the left and right boundary conditions are</span>
0035 <span class="comment">% assumed to be column vectors of (m+2)*n components, and the bottom and</span>
0036 <span class="comment">% top faces are assumed to be vectors of (m+2)*(n+2) components.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% The order of these components is as follows:</span>
0039 <span class="comment">% For left and right edges, the ordering is the one given by columns vectors</span>
0040 <span class="comment">% where x increases. For bottom and top faces, the ordering is the one given</span>
0041 <span class="comment">% by columns vectors where y increases.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% The code assumes the following assertions:</span>
0044 <span class="comment">% assert(k &gt;= 2, 'k &gt;= 2');</span>
0045 <span class="comment">% assert(mod(k, 2) == 0, 'k % 2 = 0');</span>
0046 <span class="comment">% assert(m &gt;= 2*k+1, ['m &gt;= ' num2str(2*k+1) ' for k = ' num2str(k)]);</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Parameters:</span>
0049 <span class="comment">% output</span>
0050 <span class="comment">%         A : Linear operator with boundary conditions added</span>
0051 <span class="comment">%         b : Right hand side with boundary conditions added</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% input</span>
0054 <span class="comment">%         A : Linear operator without boundary conditions added</span>
0055 <span class="comment">%         b : Right hand side without boundary conditions added</span>
0056 <span class="comment">%         k : Order of accuracy</span>
0057 <span class="comment">%         m : Number of horizontal cells</span>
0058 <span class="comment">%        dx : Step size horizontal cells</span>
0059 <span class="comment">%         n : Number of vertical cells</span>
0060 <span class="comment">%        dy : Step size of vertical cells</span>
0061 <span class="comment">%        dc : a0 (4x1 vector for left, right, bottom, top boundaries, resp.)</span>
0062 <span class="comment">%        nc : b0 (4x1 vector for left, right, bottom, top boundaries, resp.)</span>
0063 <span class="comment">%         v : g (4x1 vector of arrays for left, right, bottom, top boundaries, resp.)</span>
0064 <span class="comment">% ----------------------------------------------------------------------------</span>
0065 <span class="comment">% SPDX-License-Identifier: GPL-3.0-or-later</span>
0066 <span class="comment">% Â© 2008-2024 San Diego State University Research Foundation (SDSURF).</span>
0067 <span class="comment">% See LICENSE file or https://www.gnu.org/licenses/gpl-3.0.html for details.</span>
0068 <span class="comment">% ----------------------------------------------------------------------------</span>
0069 
0070     <span class="comment">% verify bc sizes and square linear system</span>
0071     assert(all(size(dc) == [4 1]), <span class="string">'dc is a 4x1 vector'</span>);
0072     assert(all(size(nc) == [4 1]), <span class="string">'nc is a 4x1 vector'</span>);
0073     assert(all(size(v) == [4 1]), <span class="string">'v is a 4x1 vector'</span>);
0074     cellsz = cellfun(@size,v,<span class="string">'uni'</span>,false);
0075     assert(all(cellsz{1} == [n 1]), <span class="string">'v{1} is a nx1 vector'</span>); <span class="comment">% left</span>
0076     assert(all(cellsz{2} == [n 1]), <span class="string">'v{2} is a nx1 vector'</span>); <span class="comment">% right</span>
0077     assert(all(cellsz{3} == [m+2 1]), <span class="string">'v{3} is a (m+2)x1 vector'</span>); <span class="comment">% bottom</span>
0078     assert(all(cellsz{4} == [m+2 1]), <span class="string">'v{4} is a (m+2)x1 vector'</span>); <span class="comment">% top</span>
0079     assert(all(size(A,1) == size(A,2)), <span class="string">'A is a square matrix'</span>);
0080     assert(all(size(A,2) == numel(b)), <span class="string">'b size = A columns'</span>);
0081 
0082     <span class="comment">% get modifications of A for left, right, bottom, top edges, resp.</span>
0083     [Abcl,Abcr,Abcb,Abct] = <a href="addBC2Dlhs.html" class="code" title="function [Abcl,Abcr,Abcb,Abct] = addBC2Dlhs(k, m, dx, n, dy, dc, nc)">addBC2Dlhs</a>(k, m, dx, n, dy, dc, nc);
0084 
0085     <span class="comment">% get rhs entries affected by bcs for left, right, bottom, top edges, resp.</span>
0086     [rl,~,~] = find(Abcl);
0087     [rr,~,~] = find(Abcr);
0088     [rb,~,~] = find(Abcb);
0089     [rt,~,~] = find(Abct);
0090 
0091     <span class="comment">% remove rows of A associated to boundary</span>
0092     Abc = Abcl + Abcr + Abct + Abcb;
0093     [rowsbc,~,~] = find(Abc);
0094     [rows,cols,s] = find(A(rowsbc,:));
0095     A = A - sparse(rows, cols, s, size(A,1), size(A,2));
0096     <span class="comment">% update matrix A with boundary information</span>
0097     A = A + Abc;
0098 
0099     <span class="comment">% remove b entries associated to bcs</span>
0100     b(rowsbc) = 0;    
0101     <span class="comment">% update b with boundary information</span>
0102     b = <a href="addBC2Drhs.html" class="code" title="function b = addBC2Drhs(b, dc, nc, v, rl, rr, rb, rt)">addBC2Drhs</a>(b, dc, nc, v, rl, rr, rb, rt);
0103 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Tue 18-Mar-2025 18:53:27 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>
