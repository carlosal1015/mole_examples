<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of addScalarBC2D</title>
  <meta name="keywords" content="addScalarBC2D">
  <meta name="description" content="This function assumes that the unknown u, which represents the discrete">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="index.html">matlab_octave</a> &gt; addScalarBC2D.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src/matlab_octave&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>addScalarBC2D
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This function assumes that the unknown u, which represents the discrete</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [A, b] = addScalarBC2D(A, b, k, m, dx, n, dy, dc, nc, v) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> This function assumes that the unknown u, which represents the discrete
 solution the continuous second-order 2D PDE operator 
                                   L U = f, 
 with continuous boundary condition 
                              a0 U + b0 dU/dn = g,
 are given at the 2D cell centers and boundary face centers. Furthermore,
 all discrete calculations are performed at the 2D cell centers and boundary 
 face centers.

 The function receives as input quantities associated to the discrete
 analog of the continuous problem given by the squared linear system 
                                 A u = b 
 where A is the discrete analog of L and b is the discrete analog of g,
 both constructed by the user without boundary conditions.
 The function output is the modified square linear system 
                                 A u = b
 where both A and b include boundary condition information.

 The boundary condition is always one of the following forms:

 For Dirichlet set: a0 not equal zero and b0 = 0.
 For Neumann set  : a0 = 0 and b0 not equal zero.
 For Robin set    : both a0 and b0 not equal zero.
 For Periodic set : both a0 = 0 and b0 = 0.

 For periodic bc, it is assumed that not only u but also du/dn are the same 
 in both extremes of the domain since a second-order PDE is assumed.

 Periodic boundary conditions can be applied along some axes and
 non-periodic to some others.
 
 For consistence with the way boundary operators are calculated to avoid 
 overwriting of the values v, the left and right boundary conditions are
 assumed to be column vectors of (m+2)*n components, and the bottom and 
 top faces are assumed to be vectors of (m+2)*(n+2) components. 

 The order of these components is as follows:
 For left and right edges, the ordering is the one given by columns vectors
 where x increases. For bottom and top faces, the ordering is the one given 
 by columns vectors where y increases.

 The code assumes the following assertions:
 assert(k &gt;= 2, 'k &gt;= 2');
 assert(mod(k, 2) == 0, 'k % 2 = 0');
 assert(m &gt;= 2*k+1, ['m &gt;= ' num2str(2*k+1) ' for k = ' num2str(k)]);

 Parameters:
 output
         A : Linear operator with boundary conditions added
         b : Right hand side with boundary conditions added

 input
         A : Linear operator without boundary conditions added
         b : Right hand side without boundary conditions added
         k : Order of accuracy
         m : Number of horizontal cells
        dx : Step size horizontal cells
         n : Number of vertical cells
        dy : Step size of vertical cells
        dc : a0 (4x1 vector for left, right, bottom, top boundaries, resp.)
        nc : b0 (4x1 vector for left, right, bottom, top boundaries, resp.)
         v : g (4x1 vector of arrays for left, right, bottom, top boundaries, resp.)

 ----------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-3.0-or-later
 © 2008-2024 San Diego State University Research Foundation (SDSURF).
 See LICENSE file or https://www.gnu.org/licenses/gpl-3.0.html for details.
 ----------------------------------------------------------------------------

</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="addScalarBC2Dlhs.html" class="code" title="function [Abcl,Abcr,Abcb,Abct] = addScalarBC2Dlhs(k, m, dx, n, dy, dc, nc)">addScalarBC2Dlhs</a>	This functions uses geometry and boundary type conditions to create</li>
<li><a href="addScalarBC2Drhs.html" class="code" title="function b = addScalarBC2Drhs(b, dc, nc, v, rl, rr, rb, rt)">addScalarBC2Drhs</a>	function b = addBC2Drhs(b, m, n, dc, nc, v, vec)</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [A, b] = addScalarBC2D(A, b, k, m, dx, n, dy, dc, nc, v)</a>
0002 <span class="comment">% This function assumes that the unknown u, which represents the discrete</span>
0003 <span class="comment">% solution the continuous second-order 2D PDE operator</span>
0004 <span class="comment">%                                   L U = f,</span>
0005 <span class="comment">% with continuous boundary condition</span>
0006 <span class="comment">%                              a0 U + b0 dU/dn = g,</span>
0007 <span class="comment">% are given at the 2D cell centers and boundary face centers. Furthermore,</span>
0008 <span class="comment">% all discrete calculations are performed at the 2D cell centers and boundary</span>
0009 <span class="comment">% face centers.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% The function receives as input quantities associated to the discrete</span>
0012 <span class="comment">% analog of the continuous problem given by the squared linear system</span>
0013 <span class="comment">%                                 A u = b</span>
0014 <span class="comment">% where A is the discrete analog of L and b is the discrete analog of g,</span>
0015 <span class="comment">% both constructed by the user without boundary conditions.</span>
0016 <span class="comment">% The function output is the modified square linear system</span>
0017 <span class="comment">%                                 A u = b</span>
0018 <span class="comment">% where both A and b include boundary condition information.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% The boundary condition is always one of the following forms:</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% For Dirichlet set: a0 not equal zero and b0 = 0.</span>
0023 <span class="comment">% For Neumann set  : a0 = 0 and b0 not equal zero.</span>
0024 <span class="comment">% For Robin set    : both a0 and b0 not equal zero.</span>
0025 <span class="comment">% For Periodic set : both a0 = 0 and b0 = 0.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% For periodic bc, it is assumed that not only u but also du/dn are the same</span>
0028 <span class="comment">% in both extremes of the domain since a second-order PDE is assumed.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Periodic boundary conditions can be applied along some axes and</span>
0031 <span class="comment">% non-periodic to some others.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% For consistence with the way boundary operators are calculated to avoid</span>
0034 <span class="comment">% overwriting of the values v, the left and right boundary conditions are</span>
0035 <span class="comment">% assumed to be column vectors of (m+2)*n components, and the bottom and</span>
0036 <span class="comment">% top faces are assumed to be vectors of (m+2)*(n+2) components.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% The order of these components is as follows:</span>
0039 <span class="comment">% For left and right edges, the ordering is the one given by columns vectors</span>
0040 <span class="comment">% where x increases. For bottom and top faces, the ordering is the one given</span>
0041 <span class="comment">% by columns vectors where y increases.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% The code assumes the following assertions:</span>
0044 <span class="comment">% assert(k &gt;= 2, 'k &gt;= 2');</span>
0045 <span class="comment">% assert(mod(k, 2) == 0, 'k % 2 = 0');</span>
0046 <span class="comment">% assert(m &gt;= 2*k+1, ['m &gt;= ' num2str(2*k+1) ' for k = ' num2str(k)]);</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Parameters:</span>
0049 <span class="comment">% output</span>
0050 <span class="comment">%         A : Linear operator with boundary conditions added</span>
0051 <span class="comment">%         b : Right hand side with boundary conditions added</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% input</span>
0054 <span class="comment">%         A : Linear operator without boundary conditions added</span>
0055 <span class="comment">%         b : Right hand side without boundary conditions added</span>
0056 <span class="comment">%         k : Order of accuracy</span>
0057 <span class="comment">%         m : Number of horizontal cells</span>
0058 <span class="comment">%        dx : Step size horizontal cells</span>
0059 <span class="comment">%         n : Number of vertical cells</span>
0060 <span class="comment">%        dy : Step size of vertical cells</span>
0061 <span class="comment">%        dc : a0 (4x1 vector for left, right, bottom, top boundaries, resp.)</span>
0062 <span class="comment">%        nc : b0 (4x1 vector for left, right, bottom, top boundaries, resp.)</span>
0063 <span class="comment">%         v : g (4x1 vector of arrays for left, right, bottom, top boundaries, resp.)</span>
0064 <span class="comment">%</span>
0065 <span class="comment">% ----------------------------------------------------------------------------</span>
0066 <span class="comment">% SPDX-License-Identifier: GPL-3.0-or-later</span>
0067 <span class="comment">% © 2008-2024 San Diego State University Research Foundation (SDSURF).</span>
0068 <span class="comment">% See LICENSE file or https://www.gnu.org/licenses/gpl-3.0.html for details.</span>
0069 <span class="comment">% ----------------------------------------------------------------------------</span>
0070 <span class="comment">%</span>
0071 
0072     <span class="comment">% verify bc sizes and square linear system</span>
0073     cellsz = cellfun(@size,v,<span class="string">'uni'</span>,false);
0074     assert(all(size(dc) == [4 1]), <span class="string">'dc is a 4x1 vector'</span>);
0075     assert(all(size(nc) == [4 1]), <span class="string">'nc is a 4x1 vector'</span>);
0076     assert(all(size(v) == [4 1]), <span class="string">'v is a 4x1 vector'</span>);
0077     assert(all(size(A,1) == size(A,2)), <span class="string">'A is a square matrix'</span>);
0078     assert(all(size(A,2) == numel(b)), <span class="string">'b size = A columns'</span>);
0079 
0080     <span class="comment">% A and b changes depend on whether bc is periodic or not in each axis</span>
0081     qrl = find(dc(1:2).*dc(1:2) + nc(1:2).*nc(1:2),1);
0082     qbt = find(dc(3:4).*dc(3:4) + nc(3:4).*nc(3:4),1);
0083 
0084     <span class="comment">% verify bc data sizes for non-periodic boundary condition</span>
0085     <span class="keyword">if</span> ~isempty(qrl)    
0086         assert(all(cellsz{1} == [n 1]), <span class="string">'v{1} is a nx1 vector'</span>); <span class="comment">% left</span>
0087         assert(all(cellsz{2} == [n 1]), <span class="string">'v{2} is a nx1 vector'</span>); <span class="comment">% right</span>
0088     <span class="keyword">end</span>
0089 
0090     <span class="keyword">if</span> ~isempty(qbt)
0091         <span class="keyword">if</span> ~isempty(qrl)    
0092             assert(all(cellsz{3} == [m+2 1]), <span class="string">'v{3} is a (m+2)x1 vector'</span>); <span class="comment">% bottom</span>
0093             assert(all(cellsz{4} == [m+2 1]), <span class="string">'v{4} is a (m+2)x1 vector'</span>); <span class="comment">% top</span>
0094         <span class="keyword">else</span>
0095             assert(all(cellsz{3} == [m 1]), <span class="string">'v{3} is a mx1 vector'</span>); <span class="comment">% bottom</span>
0096             assert(all(cellsz{4} == [m 1]), <span class="string">'v{4} is a mx1 vector'</span>); <span class="comment">% top</span>
0097         <span class="keyword">end</span>
0098     <span class="keyword">end</span>
0099 
0100     rl = 0; rr = 0; rb = 0; rt = 0; <span class="comment">% periodic case</span>
0101 
0102     <span class="comment">% get modifications of A for left, right, bottom, top edges, resp.</span>
0103     [Abcl,Abcr,Abcb,Abct] = <a href="addScalarBC2Dlhs.html" class="code" title="function [Abcl,Abcr,Abcb,Abct] = addScalarBC2Dlhs(k, m, dx, n, dy, dc, nc)">addScalarBC2Dlhs</a>(k, m, dx, n, dy, dc, nc);
0104 
0105     <span class="comment">% get rhs entries affected by bcs for left, right, bottom, top edges, resp.</span>
0106     <span class="keyword">if</span> ~isempty(qrl)    
0107         [rl,~,~] = find(Abcl);
0108         [rr,~,~] = find(Abcr);
0109         rl = unique(rl);
0110         rr = unique(rr);
0111         <span class="comment">% remove rows of A associated to boundary</span>
0112         Abc1 = Abcl + Abcr;
0113         [rowsbc1,~,~] = find(Abc1);
0114         [rows1,cols1,s1] = find(A(rowsbc1,:));
0115         A = A - sparse(rows1, cols1, s1, size(A,1), size(A,2));
0116         <span class="comment">% update matrix A with boundary information</span>
0117         A = A + Abc1;    
0118         <span class="comment">% remove b entries associated to bcs</span>
0119         b(rowsbc1) = 0;    
0120     <span class="keyword">end</span>
0121 
0122     <span class="keyword">if</span> ~isempty(qbt)
0123         [rb,~,~] = find(Abcb);
0124         [rt,~,~] = find(Abct);
0125         rb = unique(rb);
0126         rt = unique(rt);
0127         <span class="comment">% remove rows of A associated to boundary</span>
0128         Abc2 = Abct + Abcb;
0129         [rowsbc2,~,~] = find(Abc2);
0130         [rows2,cols2,s2] = find(A(rowsbc2,:));
0131         A = A - sparse(rows2, cols2, s2, size(A,1), size(A,2));
0132         <span class="comment">% update matrix A with boundary information</span>
0133         A = A + Abc2;
0134         <span class="comment">% remove b entries associated to bcs</span>
0135         b(rowsbc2) = 0;    
0136     <span class="keyword">end</span>
0137 
0138     <span class="comment">% update b with boundary information</span>
0139     <span class="keyword">if</span> ~(isempty(qrl) &amp;&amp; isempty(qbt))  
0140         b = <a href="addScalarBC2Drhs.html" class="code" title="function b = addScalarBC2Drhs(b, dc, nc, v, rl, rr, rb, rt)">addScalarBC2Drhs</a>(b, dc, nc, v, rl, rr, rb, rt);
0141     <span class="keyword">end</span>
0142 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Sun 02-Nov-2025 21:28:13 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>
