\chapter{Core Mimetic Operators}

\section{Divergence operator}

\subsection{1D Formulation}
The one-dimensional mimetic divergence operator $div(k,m,k)$, where $k$: order of accuracy, $m$: number of cells and $dx$: step size. The operator $div$ is a matrix of order $m+2$ by $m+1$. Where $k$ can take values $​​2, 4, 6$ and $8$; $m > 2*k+1$, that is:\\

if $k=2$, then the minimum value it takes $m=5$\\
if $k=4$, then the minimum value it takes $m=9$\\
if $k=6$, then the minimum value it takes $m=13$\\
if $k=8$, then the minimum value it takes $m=17$\\
\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{div.m}
	\caption{Program~\texttt{div.m}}
	\label{code:div.m}
\end{listing}


Example: If  $K=2$, $m=5$ and $dx=1$, then the divergence matrix is ​​of order 7 by 6.

\begin{equation}
	D= (\frac{1}{dx})\begin{pmatrix}
		0  & 0  & 0  & 0  & 0  & 0 \\
		-1 & 1  & 0  & 0  & 0  & 0 \\
		0  & -1 & 1  & 0  & 0  & 0 \\
		0  & 0  & -1 & 1  & 0  & 0 \\
		0  & 0  & 0  & -1 & 1  & 0 \\
		0  & 0  & 0  & 0  & -1 & 1 \\
		0  & 0  & 0  & 0  & 0  & 0 \\
	\end{pmatrix}
\end{equation}



\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{divergence.h}
	\caption{Program~\texttt{divergence.h}}
	\label{code:divergence.h}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos,firstline=1,lastline=100]{python}{div1D.py}
	\caption{Program~\texttt{div1D.py}}
	\label{code:div1D.py}
\end{listing}

\subsection{2D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{div2D.m}
	\caption{Program~\texttt{div2D.m}}
	\label{code:div2D.m}
\end{listing}

\subsection{3D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{div3D.m}
	\caption{Program~\texttt{div3D.m}}
	\label{code:div3D.m}
\end{listing}

\section{Gradient Operator}

\subsection{1D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{grad.m}
	\caption{Program~\texttt{grad.m}}
	\label{code:grad.m}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{gradient.h}
	\caption{Program~\texttt{gradient.h}}
	\label{code:gradient.h}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos,firstline=1,lastline=100]{python}{grad1D.py}
	\caption{Program~\texttt{grad1D.py}}
	\label{code:grad1D.py}
\end{listing}

\subsection{2D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{grad2D.m}
	\caption{Program~\texttt{grad2D.m}}
	\label{code:grad2D.m}
\end{listing}

\subsection{3D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{grad3D.m}
	\caption{Program~\texttt{grad3D.m}}
	\label{code:grad3D.m}
\end{listing}

\section{Laplacian Operator}

\subsection{1D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{lap.m}
	\caption{Program~\texttt{lap.m}}
	\label{code:lap.m}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{laplacian.h}
	\caption{Program~\texttt{laplacian.h}}
	\label{code:laplacian.h}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos,firstline=1,lastline=18]{python}{lap1D.py}
	\caption{Program~\texttt{lap1D.py}}
	\label{code:lap1D.py}
\end{listing}

\subsection{2D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{lap2D.m}
	\caption{Program~\texttt{lap2D.m}}
	\label{code:lap2D.m}
\end{listing}

\subsection{3D Formulation}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{lap3D.m}
	\caption{Program~\texttt{lap3D.m}}
	\label{code:lap3D.m}
\end{listing}

\section{Interpolation Operators}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{interpol.m}
	\caption{Program~\texttt{interpol.m}}
	\label{code:interpol.m}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{interpol2D.m}
	\caption{Program~\texttt{interpol2D.m}}
	\label{code:interpol2D.m}
\end{listing}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{interpol3D.m}
	\caption{Program~\texttt{interpol3D.m}}
	\label{code:interpol3D.m}
\end{listing}

% \subsection{Center $\longleftrightarrow$ Nodes (1D, 2D, 3D)}
% \subsection{Center $\longleftrightarrow$ Faces (1D, 2D, 3D)}
% \subsection{Nodes $\longleftrightarrow$ Faces (1D, 2D, 3D)}

% interpolCentersToFacesD1D.m
% \section{Interpolation 1D from center to nodes}
% \section{Interpolation 2D from center to nodes}
% \section{Interpolation 3D from center to nodes}
% \section{Interpolation 1D from center to faces}
% \section{Interpolation 2D from center to faces}
% \section{Interpolation 3D from center to faces}
% \section{Interpolation 1D from nodes to center}
% \section{Interpolation 2D from nodes to center}
% \section{Interpolation 3D from nodes to center}
% \section{Interpolation 1D from faces to center}
% \section{Interpolation 2D from faces to center}
% \section{Interpolation 3D from faces to center}

\section{Boundary Condition Implementation}

\subsection{1D Boundary Handling}

\begin{listing}[ht!]
	\tiny
	\centering
	\pathinputminted[frame=single,framesep=10pt,linenos]{octave}{addBC1D.m}
	\caption{Program~\texttt{addBC1D.m}}
	\label{code:addBC1D.m}
\end{listing}

\subsection{2D/3D Boundary Handling}

Let be
\begin{math}
	f,g\colon\Omega\subset\mathbb{R}^{n}\to
	\mathbb{R}
\end{math}
are scalar fields.
Let be
\begin{math}
	\vec{v},\vec{w}\colon\Omega\subset\mathbb{R}^{n}\to
	\mathbb{R}^{m}
\end{math}
are vector fields.

\begin{align*}
	\left\langle
	f,g
	\right\rangle & =
	\int_{\Omega}fg \dl V. \\
	\left\langle
	\vec{v},\vec{w}
	\right\rangle & =
	\int_{\Omega}\vec{v}\vec{w}\dl V.
\end{align*}

\begin{align*}
	\left\langle
	\symbf{D}\vec{v},
	f
	\right\rangle+
	\left\langle
	\vec{v},
	\symbf{G}f
	\right\rangle & =
	\int_{\partial\Omega}
	f\vec{v}\cdot\vec{n}\dl S.
\end{align*}

\begin{align*}
	\symbf{G}\colon\mathbb{R}^{n+2} & \longrightarrow
	\mathbb{R}^{n+1}                                  \\
	f                               & \longmapsto
	\symbf{G}f.
\end{align*}

\begin{align*}
	\symbf{D}\colon\mathbb{R}^{n+1} & \longrightarrow
	\mathbb{R}^{n}                                    \\
	\vec{v}                         & \longmapsto
	\symbf{D}\vec{v}.
\end{align*}

\begin{align*}
	\symbf{B}\colon\mathbb{R}^{n+2} & \longrightarrow
	\mathbb{R}^{n+1}                                  \\
	\vec{v}                         & \longmapsto
	\symbf{B}\vec{v}.
\end{align*}

\begin{theorem}{}{}
	Let be
	\begin{math}
		f=
		\begin{bNiceMatrix}
			f_{0}             &
			f_{\frac{1}{2}}   &
			f_{\frac{3}{2}}   &
			\cdots            &
			f_{n-\frac{1}{2}} &
			f_{n}
		\end{bNiceMatrix}^{T}\in\mathbb{R}^{n+2}
	\end{math}
	a discretized function defined at the cell centers and
	at the boundary of the 1D mesh.
	Let be
	\begin{math}
		v=
		\begin{bNiceMatrix}
			v_{0}  &
			v_{1}  &
			\cdots &
			v_{n}
		\end{bNiceMatrix}^{T}\in\mathbb{R}^{n+1}
	\end{math}
	a discretized function defined on the nodes of the 1D mesh.

	\begin{itemize}
		\item

		      \begin{math}
			      \symbf{G}f=
			      0\iff f=
			      c
		      \end{math}.

		\item

		      \begin{math}
			      \symbf{D}\vec{v}=
			      0\iff\vec{v}=
			      c
		      \end{math}.
	\end{itemize}
\end{theorem}

\begin{proof}\leavevmode
	\begin{itemize}
		\item

		      \begin{align*}
			      \symbf{D}\vec{v} & =
			      \frac{v_{i+1}-v_{i}}{\Delta x}. \\
			      0                & =
			      \frac{v_{i+1}-v_{i}}{\Delta x}.
		      \end{align*}

		\item

		      \begin{align*}
			      \symbf{G}f & =
			      \frac{f_{i+\frac{1}{2}}-f_{i-\frac{1}{2}}}{\Delta x}.
		      \end{align*}
	\end{itemize}
\end{proof}

\begin{equation*}
	\symbf{G}_{x}u=
	\symbf{G}u\left(x_{i},y_{j+\frac{1}{2}}\right)=
	\symbf{G}_{i,j+\frac{1}{2}}.
\end{equation*}

\begin{equation*}
	\symbf{G}_{y}u=
	\symbf{G}u\left(x_{i+\frac{1}{2}},y_{j}\right)=
	\symbf{G}_{i+\frac{1}{2},j}.
\end{equation*}

\begin{equation*}
	\symbf{D}_{\vec{v}}\left(x_{i+\frac{1}{2}},y_{j+\frac{1}{2}}\right)=
	\symbf{D}\vec{v}_{i+\frac{1}{2},j+\frac{1}{2}}.
\end{equation*}
